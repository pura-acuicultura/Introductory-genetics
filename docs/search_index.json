[["index.html", "Introductory genetics through tilapia breeding simulations Chapter 1 Introduction", " Introductory genetics through tilapia breeding simulations PURA acuicultura 2021-01-05 Chapter 1 Introduction AlphaSimR is a powerful platform for carrying out breeding simulations. Rather than working in phenotypic measures, simulations in AlphaSimR are carried out at the level of genome. Any level of genomic architecture can be simulated. Chromosome number and length, segregation site and loci number, ploidy level, etc. are all programmable. In fact, the simulator is much more limited by our understanding of fish genomes than by its capabilities. In this chapter we will learn about AlphaSimR by doing. In understanding how AlphaSimR works it will be impossible to avoid a number of fundamental themes relating to genetics, including quantitative, population, and molecular. We will provide some necessary background, but no where near what is available in standard texts on the subjects. As such, look for recommended references for a deeper understanding. Specific goals of the chapter include: Take a closer look at AlphaSimR and how it is used for breeding simulation Follow a small population through one generation to understand recombination Examine important measures of population genetics across multiple generations Develop an additive trait and examine the quantitative trait loci underlying the trait Learn how to create simple physical maps of the genome Develop tilapia-like genomes and populations for breeding simulations "],["a-brief-introduction-to-alphasimr.html", "Chapter 2 A brief introduction to AlphaSimR 2.1 Introduction 2.2 Creating founder haplotypes 2.3 Setting simulation parameters", " Chapter 2 A brief introduction to AlphaSimR 2.1 Introduction library(AlphaSimR) library(tidyverse) 2.2 Creating founder haplotypes In creating a population for simulation you need to first develop the founder haplotypes. In creating the founder haplotypes, the genomic architecture of the simulated organism is defined. In AlphaSimR, haplotypes are binary strings of 0s and 1s. Strings are arranged in pre-defined chromosome numbers and lengths in units of segregation sites. Given that the custom development of haplotypes can be a bit overwhelming to first time users, the function quickHaplo() can initially be used to get started. quickHaplo() makes it easy to define the number of individuals, number of chromosomes per individual, number of segregation sites per chromosome, ploidy level, and the genetic length of chromosomes in units of Morgans. An option for creating inbred founders is also available for more advanced users. The code to create haplotypes for 10 individuals having extremely simple single chromosome diploid genomes is shown below. pop_haplos &lt;- quickHaplo(nInd = 10, # number of individuals nChr = 1, # number of chromosomes segSites = 10, # number of segregation sites genLen = 1, # genetic length in Morgans ploidy = 2L, # ploidy level of organism inbred = FALSE) # are founders inbred? quickHaplo() saves haplotypes as a MapPop class object. Each slot can be accessed using an @ symbol. Of course, slots in the form of lists require additional designations within []. The MapPop object provides a record of important genome characteristics. Knowing how to access these characteristics is important to the analysis of breeding simulations. The following information can be obtained and/or modified through the MapPop object. pop_haplos@genMap[1] # a vector of segregation sites locations (M) per [chromosome] pop_haplos@centromere[1] # a vector of centromere location (M) per [chromosome] pop_haplos@nInd # the number of individuals pop_haplos@nChr # the number of chromosomes pop_haplos@ploidy # the ploidy of individuals pop_haplos@nLoci[1] # a vector of loci number per [chromosome] pop_haplos@geno[1] # matrices of haplotypes per [individual] As suggested through the name, MapPop class objects contain information about the physical map, or genomic architecture, of the simulated organisms. Chromosome number, segregation site location, ploidy, loci number, and centromere location are all central to the physical mapping of a genome. We will discuss all of these items in greater detail in Chapter 5, Physical mapping of simulated genomes. Here, it is important to note that genome length in AlphaSimR is not defined in base pairs, but rather Morgans. Being a measure of genetic linkage, chromosome length interacts directly with MapPop information in guiding the formation of gametes (NB: meiosis) in the simulated organism. Being of great importance to breeding simulations, genetic length is discussed in more detail in Chapter 3, An overview of recombination. When applied to a MapPop class object, the function pullSegSiteHaplo() returns the simulated haplotypes. The code and first few lines of the output are shown below. haplos &lt;- pullSegSiteHaplo(pop = pop_haplos, # Pop-class object haplo = &quot;all&quot;, # &quot;all&quot; or use 1 for males and 2 for females chr = 1) # chromosome number, NULL = all head(haplos) ## SITE_1 SITE_2 SITE_3 SITE_4 SITE_5 SITE_6 SITE_7 SITE_8 SITE_9 SITE_10 ## 1_1 1 1 0 0 1 0 0 0 1 1 ## 1_2 0 0 0 1 0 1 1 1 1 1 ## 2_1 0 1 1 1 1 0 0 1 0 0 ## 2_2 1 0 1 1 0 1 0 1 0 0 ## 3_1 1 1 0 1 0 0 1 0 1 0 ## 3_2 1 1 1 1 1 1 1 1 1 1 pullSegSiteHaplo() returns a m x n matrix where each row equates to a haplotype (m) and each column to a loci (n). Haplotypes are labeled using an individual ID number and a haplotype number, separated by an underscore. Loci are simply labeled in ascending order as SITE_1, SITE_2, etc. For each haplotype x loci combination the allele has been randomly defined as either 0 or 1. As the developers of AlphaSimR clearly state in a vignette associated with the package (NB: vignette(\"intro\", package = \"AlphaSimR\")), the quickHaplo() approach to haplotype development, is equivalent to modeling a population in linkage and Hardy-Weinberg equilibrium with allele frequencies of 0.5. This approach is very rapid but does not generate realistic haplotypes. This makes the approach great for prototyping code, but ill-suited for some types of simulations. We use quickHaplo() throughout the introductory genetic lessons but will discuss the alternatives such as runMacs and newMapPop in Chapter 7, Simulating a tilapia genome. 2.3 Setting simulation parameters After defining the founder population haplotypes, simulation parameters are set. As their name implies, simulation parameters define the conditions through which a simulation operates. AlphaSimR possesses a myriad of simulation parameters  far more than can be covered here. A review of the most important parameters to the breeding simulations covered throughout the book are illustrated here. The first step in defining simulation parameters is to create a SimParam object. After this is done, simulation parameters can be added sequentially. SP = SimParam$new(pop_haplos) # create a variable for storing new simulation parameters 2.3.1 Adding traits to a breeding simulation When paired in diploid individuals, the binary haplotypes become genotypes. At a given locus an individual can be 00, 01, or 11. While it is possible to simply simulate and evaluate genotypic changes in AlphaSimR, most breeding simulations aim to also explore phenotypic change. The first step in simulating phenotypic change is define linkages between the genotypes of specific loci and traits of interest for simulation. Traits of any complexity can be added. SP$addTraitA(nQtlPerChr = 3, # number of QTL for trait mean = 454, # mean genetic value of the trait var = 50, # variance of trait in population corA = NULL, # matrix of correlations between additive effects gamma = FALSE, # to use a gamma distribution in place of a normal distribution shape = 1, # shape parameter for gamma distribution only force = FALSE) # keep false until this is understood! "],["recombination.html", "Chapter 3 Recombination 3.1 Introduction 3.2 Create parent generation 3.3 Make a full-sib family 3.4 Haplotypes of the parent generation 3.5 Haplotypes of the offspring generation 3.6 Assigning parental haplotypes to offspring haplotypes", " Chapter 3 Recombination 3.1 Introduction In exploring recombination, AlphaSimR is used to create parents and make full sib families. In the assessment of recombination a few other libraries are used: Matrix, tidyverse, and gridExtra. library(AlphaSimR) library(Matrix) library(tidyverse) library(gridExtra) 3.2 Create parent generation To understand how recombination works in AlphaSimR we start with a simple model that can be built upon later. We start by using the quickHaplo command to create two parent fish, each diploid with a single chromosome having 10 segregation sites. The length of the chromosome in Morgans is a key determinant of recombination. We will start with a value of 1 cM and then explore how chromosome length impacts recombination. founderPop &lt;- quickHaplo(nInd = 2, nChr = 1, segSites = 10, genLen = 1, ploidy = 2L, inbred = FALSE) SP &lt;- SimParam$new(founderPop) pop1 &lt;- newPop(founderPop, simParam = SP) 3.3 Make a full-sib family Meiotic recombination in parent fish can be observed in the haplotypes of their offspring. We use the makeCross command to simulate the cross. The command requires a cross plan in the form of a two column matrix. The rows of the matrix correspond to the cross and the columns indicate the parents. We make only a single cross of parents 1 and 2. Consequently, our cross plan matrix is straightforward. crossPlan &lt;- matrix(c(1, 2), nrow = 1, ncol = 2) crossPlan ## [,1] [,2] ## [1,] 1 2 Aside from the cross plan, we only need to specify the number of progeny to create. High fecundity in fish is statistically convenient with regards to progeny analysis. We start with a relatively modest 10 progeny but can increase the progeny number to 100 or more later. pop2 &lt;- makeCross(pop = pop1, crossPlan = crossPlan, nProgeny = 10, simParam = SP) 3.4 Haplotypes of the parent generation In performing a simulation we have access to information that would be difficult or near impossible to achieve in the real world. Phased haplotypes are one such piece of information, that is also important in the analysis of recombination. We discuss how phased haplotypes can be predicted from actual SNP data in a later chapter. Since our goal here is to understand recombination in AlphaSimR, we simply pull them from the simulation. We start with the parent haplotypes. We pull the haplotypes using the pullSegSiteHaplo command. A matrix of binary haplotypes is returned by parent (m = 4) and loci (n = 10). More specifically, row 1 corresponds to parent 1 / haplotype 1, row 2 to parent 1 / haplotype 2, row 3 to parent 2 / haplotype 1, and row 4 to parent 2 / haplotype 2. As such, column 1, referred to as SITE_1, corresponds to the binary allele (0/1) present at loci 1 of the four parents. Subsequent columns correspond to the remaining alleles designated by our founderPop. Now you can appreciate why we started with a small example. par_H &lt;- pullSegSiteHaplo(pop = pop1, haplo = &quot;all&quot;, chr = 1, simParam = SP) par_H ## SITE_1 SITE_2 SITE_3 SITE_4 SITE_5 SITE_6 SITE_7 SITE_8 SITE_9 SITE_10 ## 1_1 1 0 1 1 0 0 1 0 0 1 ## 1_2 1 1 1 0 0 1 0 0 1 0 ## 2_1 1 0 0 1 1 0 0 0 0 1 ## 2_2 1 0 0 1 0 0 0 1 0 0 Here we clean up the matrix for some downstream analysis. If we define matrix dimensions and names with Pop-Class objects we wont have to rewrite the code every time we increase the number of parents or segregation sites. The number of rows, or number of parental haplotypes, can be expressed as the number of parents (pop1@nInd) multiplied by their ploidy (pop1@ploidy) . The number of columns, or number of loci, can be directly called as pop1@nLoci. In naming the loci using 1:pop1@nLoci a dynamic vector accommodating any number of loci is employed. par_H &lt;- matrix(par_H, nrow = pop1@nInd * pop1@ploidy, ncol = pop1@nLoci,byrow = FALSE) colnames(par_H) &lt;- paste(&quot;L&quot;, 1:pop1@nLoci, sep = &quot;.&quot;) par_H ## L.1 L.2 L.3 L.4 L.5 L.6 L.7 L.8 L.9 L.10 ## [1,] 1 0 1 1 0 0 1 0 0 1 ## [2,] 1 1 1 0 0 1 0 0 1 0 ## [3,] 1 0 0 1 1 0 0 0 0 1 ## [4,] 1 0 0 1 0 0 0 1 0 0 3.5 Haplotypes of the offspring generation We now make a corresponding matrix of offspring haplotypes applying the exact same code to pop2. The first four offspring haplotypes are shown. off_H &lt;- pullSegSiteHaplo(pop = pop2, haplo = &quot;all&quot;, chr = 1, simParam = SP) off_H &lt;- matrix(off_H, nrow = pop2@nInd * pop2@ploidy, ncol = pop2@nLoci, byrow = FALSE) colnames(off_H) &lt;- paste(&quot;L&quot;, 1:pop2@nLoci, sep = &quot;.&quot;) head(off_H, 4) ## L.1 L.2 L.3 L.4 L.5 L.6 L.7 L.8 L.9 L.10 ## [1,] 1 1 1 0 0 1 0 0 1 0 ## [2,] 1 0 0 1 0 0 0 0 0 1 ## [3,] 1 1 1 0 0 1 0 0 1 0 ## [4,] 1 0 0 1 0 0 0 0 0 1 Although we continue using the matrices in subsequent operations, now is a good time to set up a few qualifiers so we dont lose track of which each row of loci corresponds to which individual and haplotype. Given that it will form the basis for our analysis of recombination, we will do this just for the matrix of offspring haplotypes. As for our other scripts, we make our qualifiers dynamic by using Pop-Class objects. We start by assigning an ascending haplotype ID corresponding to the numbered rows of the offspring haplotype matrix. Offspring and allele IDs are similarly assigned. The qualifiers are compiled into a data.frame. Although we could easily bind the offspring matrix to the qualifiers, a few calculations will first be performed. HAP &lt;- 1:(pop2@nInd * pop2@ploidy) ID &lt;- rep(1:pop2@nInd, each = pop2@ploidy) ALE &lt;-rep(1:pop2@ploidy, pop2@nInd) OFF_Q &lt;- data.frame(HAP, ID, ALE) head(OFF_Q, 4) ## HAP ID ALE ## 1 1 1 1 ## 2 2 1 2 ## 3 3 2 1 ## 4 4 2 2 3.6 Assigning parental haplotypes to offspring haplotypes In assessing recombination we are going to match each offspring haplotype with the parental haplotype it resembles most. We will then compare the parent / offspring haplotypes pairs to determine at which loci recombination has taken place. To do all of this matching and comparing we will use for loops. In R programming, for loops are generally avoided and replaced with apply functions. Here, a for loop is shown because it is easier to talk through. To see for loop alternatives, look at the recomb_report function code in the Appendix. The first for loop is going to compare offspring haplotypes with parental haplotypes. We first need to set up a data.frame to accept the data generate by the for loop. par_SEL &lt;- as.data.frame(matrix(0, nrow = pop2@nInd * pop2@ploidy, ncol = pop1@nInd * pop1@ploidy)) colnames(par_SEL) &lt;- 1:(pop1@nInd * pop1@ploidy) for(i in 1:(founderPop@nInd * founderPop@ploidy)){ par_SEL[,i] &lt;- rowSums((off_H - matrix(rep(par_H[i,], pop2@nInd * pop2@ploidy), nrow = pop2@nInd * pop2@ploidy, ncol = pop2@nLoci, byrow = TRUE))^2) } "],["populations.html", "Chapter 4 Populations 4.1 Introduction 4.2 Create a test population 4.3 Observe gene frequencies 4.4 Observing SNP haplotype frequencies", " Chapter 4 Populations 4.1 Introduction In exploring markers and population genetics, AlphaSimR is used to create populations. In the assessment of markers and population genetics a few other libraries are used: Matrix, tidyverse, ape, ggtree, and phanghorn. The package ape, or Analyses of Phylogenetics and Evolution is an integral package to population genetics. It is only superficially used here for the construction of neighbor joining trees based on true and marker-based genotypes. As implied in the likeness of name to ggplot, ggtree is principally used as a presentation extension of population genetics data. Here it is used specifically for the side-by-side presentation of true and marker-based neighbor-joining trees. The phangorn package was used for its capacities to compare neighbor-joining trees. As is generally the case in R, one will come across a myriad of options for performing each of these tasks. library(AlphaSimR) library(Matrix) library(tidyverse) library(ape) library(ggtree) library(phangorn) 4.2 Create a test population As for our other examples we will start with a small genome and population before scaling up. The following code creates a population of 10 diploid individuals each with a single 1 morgan chromosome with 10 loci. Different from previous examples we also add five single nucleotide polymorphism (SNP) markers. Here, AlphaSimR randomly assigns the SNP markers to the previously developed loci. In our first proof, we will identify the physical location of these markers on our single chromosome. As we continue our exploration of markers and population genetics, we also begin exploring the differences between applied and theoretical breeding practices, a theme that will be re-visited throughout our breeding simulations. pop_haps &lt;- quickHaplo(nInd = 10, nChr = 1, segSites = 10, genLen = 1, ploidy = 2L, inbred = FALSE) SP = SimParam$new(pop_haps) SP$addSnpChip(nSnpPerChr = 5, minSnpFreq = NULL, refPop = NULL) pop1 &lt;- newPop(pop_haps, simParam = SP) 4.3 Observe gene frequencies Through simulation we have access to information we wouldnt under normal circumstances. For example, we can easily calculate the gene frequency of our entire population across every locus within the genome. This can be accomplished by using the pullSegSiteHaplo command. An m haplotypes x n loci matrix of binary haplotypes is produced. From the output, population-level gene frequencies at each loci can be achieved by counting either the 0s or 1s in each column and dividing by the total number of haplotypes, or rows. The script below actually calculates the frequency of p (0ss) through this approach and then q is computed as 1 - p. The position of each locus in Morgans can be called by unlisting pop_haps@genMap. The map and gene frequencies are combined into a data frame for later use. a1 &lt;- pullSegSiteHaplo(pop = pop1, haplo = &quot;all&quot;, chr = 1, simParam = SP) a2 &lt;- matrix(a1, nrow = nrow(a1), ncol = ncol(a1), byrow = FALSE) a3 &lt;- colSums(a2 == 0) / nrow(a1) a4 &lt;- data.frame(origin = &quot;loci&quot;, pos = round((unlist(pop_haps@genMap)), 2), p = a3, q = 1 - a3) head(a4) ## origin pos p q ## 1 loci 0.00 0.60 0.40 ## 2 loci 0.11 0.45 0.55 ## 3 loci 0.22 0.50 0.50 ## 4 loci 0.33 0.60 0.40 ## 5 loci 0.44 0.60 0.40 ## 6 loci 0.56 0.35 0.65 4.4 Observing SNP haplotype frequencies In practice we wouldnt ever know the population-level gene frequencies of every loci. For species such as Atlantic salmon, Rainbow trout, and Tilapia, it is now very possible that we could have SNP haplotype frequencies at a a good number of loci. Earlier, we added to our simulation parameters an SNP chip with five SNP along the 10 loci, 1 Morgan, single chromosome of our example genome. Consequently, there will be an average of 1 SNP to every 2 loci. This is unrealistic coverage of the genome with respect to loci, but something that will be addressed towards the end of the chapter. SNP haplotype frequencies can be achieved in a very similar manner to gene frequencies. The only differences being the pullSnpHaplo command is used to acquire the m haplotypes x n loci matrix of binary haplotypes, and the getSnpMap command is needed to access SNP physical map locations. The data format is identical to the gene frequencies for easy combining. b1 &lt;- pullSnpHaplo(pop = pop1, snpChip = 1, haplo = &#39;all&#39;, chr = NULL, simParam = SP) b2 &lt;- matrix(b1, nrow = nrow(a1), ncol = ncol(b1), byrow = FALSE) b3 &lt;- colSums(b2 == 0) / nrow(b1) b4 &lt;- getSnpMap(snpChip = 1, simParam = SP) b5 &lt;- data.frame(origin = &quot;snp&quot;, pos = round(b4[3], 2), p = b3, q = 1 - b3) head(b5) ## origin site p q ## 1 snp 1 0.60 0.40 ## 2 snp 4 0.60 0.40 ## 3 snp 5 0.60 0.40 ## 4 snp 7 0.35 0.65 ## 5 snp 8 0.20 0.80 "],["physical-mapping-of-genomes.html", "Chapter 5 Physical mapping of genomes 5.1 Introduction", " Chapter 5 Physical mapping of genomes 5.1 Introduction "],["understanding-additive-traits.html", "Chapter 6 Understanding additive traits 6.1 Introduction 6.2 Simulating a population to explore additive traits 6.3 Breeding, genetic, and phenotypic value 6.4 Heritability of additive traits 6.5 Individual QTL effects 6.6 Genome wide association of additive traits 6.7 QTL mapping", " Chapter 6 Understanding additive traits 6.1 Introduction Additive genetic variation is the only heritable variance component, and as such, the most important to selection. library(AlphaSimR) library(tidyverse) library(gridExtra) library(chromPlot) library(ggrepel) 6.2 Simulating a population to explore additive traits pop_haps &lt;- quickHaplo(nInd = 1000, nChr = 1, segSites = 100, genLen = 1, ploidy = 2L, inbred = FALSE) SP &lt;- SimParam$new(pop_haps) SP$addTraitA(nQtlPerChr = 10, # number of QTL for trait mean = 100, # mean genetic value of the trait var = 10, # variance of trait corA = NULL, # matrix of correlations between additive effects gamma = FALSE, # to use a gamma distribution in place of a normal distribution shape = 1, # shape parameter for gamma distribution only force = FALSE) # keep false until this is understood! SP$setVarE(h2 = 0.5, # narrow sense heritability H2 = NULL, # broad sense heritability varE = NULL) # error variance pop_0 &lt;- newPop(pop_haps, simParam = SP) 6.3 Breeding, genetic, and phenotypic value In creating an additive trait and defining an environmental variance, AlphaSimR assigns a phenotypic value to each individual. The phenotypic value is based in part on the genotype of each individual at the designated quantitative trait loci (QTL), and part on the environmental variance parameter set when we defined narrow sense heritability as 0.5. In quantitative genetic terms, the phenotypes were simulated through a combination of non-random genetic and random environmental effects. Given our trait is completely additive, genetic effects are synonymous with additive effects in this particular case. In the real world we would only know the phenotypes. It would then be our job to partition the phenotypic variance into additive and environmental effects at the very least. In fact, this is what we will be doing in Chapters 2-6. For the purpose of this exercise, we can take advantage of the fact that this is a simulation and call our effects directly. The following code calls individual phenotypic, genetic, and breeding values, and arranges them in a data frame. pv_gram &lt;- pheno(pop_0) gv_gram &lt;- gv(pop_0) bv_gram &lt;- bv(pop_0) + mean(gv(pop_0)) pv_norm &lt;- pheno(pop_0) - mean(pheno(pop_0)) gv_norm &lt;- gv(pop_0) - mean(gv(pop_0)) bv_norm &lt;- bv(pop_0) ind_vals &lt;- data.frame(pv_gram, gv_gram, bv_gram, pv_norm, gv_norm, bv_norm) head(round(ind_vals, 2)) ## pv_gram gv_gram bv_gram pv_norm gv_norm bv_norm ## 1 99.40 94.01 94.01 -0.58 -5.99 -5.99 ## 2 97.83 101.85 101.85 -2.16 1.85 1.85 ## 3 104.54 102.55 102.55 4.56 2.55 2.55 ## 4 103.95 103.88 103.88 3.96 3.88 3.88 ## 5 95.62 94.64 94.64 -4.36 -5.36 -5.36 ## 6 96.44 99.25 99.25 -3.54 -0.75 -0.75 From the first few lines it seems genetic values and breeding values are the same. This makes sense since our simulation includes neither dominance, epistatic, or GxE effects. As such, genetic values equal breeding values which in turn derived from the additive component of phenotypic variance. Given that the estimation of breeding values is a principle theme throughout later chapters further details are limited here. However, it should be understood that the called breeding values are true breeding values and not derivations arrived at through phenotypic analysis. True breeding values, of course, are vitally important to the assessment of the breeding value estimates arrived through simulation. Through a plot of individual breeding values as a function of phenotypic values we can visualize some fundamental concepts to genetics and breeding. plot_gram &lt;- ind_vals %&gt;% ggplot(aes(x = pv_gram, y = bv_gram)) + geom_point() + geom_smooth(method=&#39;lm&#39;, formula= y ~ x) plot_norm &lt;- ind_vals %&gt;% ggplot(aes(x = pv_norm, y = bv_norm)) + geom_point() + geom_smooth(method=&#39;lm&#39;, formula= y ~ x) grid.arrange(plot_gram, plot_norm, ncol = 2) gram_mod &lt;- lm(bv_gram ~ pv_gram, data = ind_vals) norm_mod &lt;- lm(bv_norm ~ pv_norm, data = ind_vals) y_int &lt;- c(coef(gram_mod)[1], coef(norm_mod)[1]) slope &lt;- c(coef(gram_mod)[2], coef(norm_mod)[2]) herit &lt;- c(cov(ind_vals$pv_gram, ind_vals$bv_gram) / var(ind_vals$pv_gram), cov(ind_vals$pv_norm, ind_vals$bv_norm) / var(ind_vals$pv_norm)) accur &lt;- c(cor(ind_vals$pv_gram, ind_vals$bv_gram), cor(ind_vals$pv_norm, ind_vals$bv_norm)) pop_stats &lt;- data.frame(y_int, slope, herit, accur) round(pop_stats, 3) ## y_int slope herit accur ## pv_gram 48.423 0.516 0.516 0.73 ## pv_norm 0.000 0.516 0.516 0.73 6.4 Heritability of additive traits We just demonstrated that the phenotype of an additive trait is derived from two components, a nonrandom additive component and a random environmental component. We will momentarily delve deeper into the additive component, but take a moment here to further explore random environmental effects. In some animal breeding texts you will hear environmental effects described as nuisance effects. This is an apt description given the definition of nuisance as, a circumstance causing inconvenience or annoyance. The reason environmental effects can become a nuisance stems from the fact that unlike additive effects that are correlative to genotypes, environmental effects are random. The exploration of random variables is frequently performed using Monte Carlo simulations. As you might expect, R has a number of tools to support the development and analysis of Monte Carlo simulations. As a general guide, a function under the influence of a random variable is first written and the repeated using a function from the apply family. The following code creates a function called h2_MC from the population simulation script employed at the beginning of the chapter. The function takes a single argument, heritability, and returns the calculated heritability and accuracy of the simulated population. Each time the script is run all individuals are assigned a phenotype that is in turn based on a genotype-dependent breeding value and a random environmental effect. In this case, the random environmental effect is the objective of the Monte Carlo simulation. h2_MC &lt;- function(h2){ pop_haps &lt;- quickHaplo(nInd = 10, nChr = 1, segSites = 100, genLen = 1, ploidy = 2L, inbred = FALSE) SP = SimParam$new(pop_haps) SP$addTraitA(nQtlPerChr = 10, mean = 100, var = 10, corA = NULL, gamma = FALSE, shape = 1, force = FALSE) SP$setVarE(h2 = h2, H2 = NULL, varE = NULL) pop_0 &lt;- newPop(pop_haps, simParam = SP) return(list(cov(pop_0@pheno, pop_0@gv) / var(pop_0@pheno), cor(pop_0@pheno, pop_0@gv)))} After creating the function we can now use the lapply function to simulate population development as many times as we want. The following code simulates one thousand populations with a parameter heritability setting of 0.5, and returns the calculated heritability and accuracy. Results are returned as nested list items and then converted into a data frame for plotting as histograms. Histograms of both heritability and accuracy are produced. mc_results &lt;- lapply(rep(0.5, 1000), h2_MC) h2 &lt;- unlist(sapply(mc_results, function(x) x[1])) r2 &lt;- unlist(sapply(mc_results, function(x) x[2])) mc_df &lt;- data.frame(h2, r2) plot_h2 &lt;- mc_df %&gt;% ggplot() + geom_histogram(aes(x = h2), binwidth = 0.05, color = &#39;black&#39;, fill = &#39;blue&#39;, alpha = 0.5) + xlim(c(0, 1)) plot_r2 &lt;- mc_df %&gt;% ggplot() + geom_histogram(aes(x = r2), binwidth = 0.05, color = &#39;black&#39;, fill = &quot;light blue&quot;, alpha = 0.5) + xlim(c(0, 1)) grid.arrange(plot_h2, plot_r2, nrow = 1) Through the Monte Carlo simulation we find more variation than we might expect. In terms of heritability, a fairly normal distribution centered on, or near, the simulation parameter of 0.5 is noted. Deviations from 0.5 are not reflective of additive effects accounting for more or less than 50% of the phenotype, but rather correlations between additive and environmental effects. For example, if smaller fish are randomly assigned larger environmental component and larger fish smaller environmental effects, observed heritability decreases. If larger fish are randomly assigned larger environmental effects and smaller fish smaller environmental effects, heritability increases. It is important to note that in this case such correlations are arising randomly and not systematically. Evidence for randomness is in the heritability distribution itself. If the center of our distribution was significantly different from 0.5, we would have to consider why our simulation is resulting in underlying gene x environment effects. If we now turn our attention to our distribution of prediction accuracy. We can see that rather than being normal, our distribution is skewed to the right and has a long left hand tail. In fact, rather than being normal the resulting accuracies resemble a beta distribution. This is quite normal for random variables with finite intervals such as R2 values that should always be between 0 and 1. It is only strange in that we dont see the same for heritability when it increases towards 1, the theoretical limit. Heritability, however, is not mathematically constrained to this interval. In our particular case, heritability can exceed values of 1 by unknowingly including GE effects in the numerator and not in the denominator. It is also important to understand the relationship between heritability and accuracy. Accuracy, of course, is a measure of the degree to which we can predict phenotype from a breeding value. Due to its random nature, environmental variation itself reduces accuracy of 6.5 Individual QTL effects 6.6 Genome wide association of additive traits 6.7 QTL mapping "],["simulating-a-tilapia-like-genome.html", "Chapter 7 Simulating a tilapia like genome 7.1 Introduction", " Chapter 7 Simulating a tilapia like genome 7.1 Introduction "]]
